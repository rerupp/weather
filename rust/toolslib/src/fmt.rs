//! A collection of functions and macros that help format values into
//! formatted strings.
//!
use std::fmt::Display;
use thousands::policies::COMMA_SEPARATOR;
use thousands::Separable;

/// Add commas to some numeric string value.
///
/// This function is exposed to consolidate the `thousands` crate to this module
/// and not spread it across the entire playground.
///
/// # Arguments
///
/// * `value` the numeric value that will have commas added.
pub fn commafy<T: Display>(value: T) -> String {
    value.to_string().as_str().separate_by_policy(COMMA_SEPARATOR)
}

/// Creates a string representation of a float value.
///
/// If the float value is `None` an empty string will be returned.
///
/// # Arguments
///
/// * `value` the optional float value.
/// * `precision` the precision of the float being converted.
///
pub fn fmt_float(value: &Option<f64>, precision: usize) -> String {
    if let Some(float) = value {
        format!("{:.1$}", float, precision)
    } else {
        String::default()
    }
}

/// The default precision used by the multiple-byte formatters.
pub const DEFAULT_MULTIBYTE_PRECISION: usize = 3;

/// The power of 2 kilobyte.
const KIB: i64 = 1024;
/// The power of 2 megabyte.
const MIB: i64 = i64::pow(KIB, 2);
/// The power of 2 gigabyte.
const GIB: i64 = i64::pow(KIB, 3);
/// The power of 2 terabyte.
const TIB: i64 = i64::pow(KIB, 4);
/// The power of 2 petabyte.
const PIB: i64 = i64::pow(KIB, 5);

/// The default power of 2 kilobyte label.
pub const KIB_LABEL: &str = " KiB";
/// The default power of 2 megabyte label.
pub const MIB_LABEL: &str = " MiB";
/// The default power of 2 gigabyte label.
pub const GIB_LABEL: &str = " GiB";
/// The default power of 2 terabyte labels.
pub const TIB_LABEL: &str = " TiB";
/// The default power of 2 petabyte labels.
pub const PIB_LABEL: &str = " PiB";

/// Generates a multiple-byte units formatter.
///
/// This macro is used internally to generate the public functions used to format
/// multiple-byte units. The code for all of the converters (power of two, power
/// of ten, etc.) is essentially the same. The macro allows the boilder plate code
/// to be defined once and used multiple times.
///
/// # Arguments:
///
/// * `$name` is the name of the function that will be generated.
/// * `$units_base` the multiple-bytes unit base such as `1000` or `1024`.
///
/// It generates a function with the following signature.
///
/// `pub fn name<T: TryInto<i64>>(size: T, precision: usize, unit_lbl: &str) -> String { ... }`
///
/// # Example
///
/// The following example shows how to use the macro. The `kbfmt` function is essentially
/// a reference implementation of the code generated by the macro.
///
/// ```
/// # use toolslib::build_units_converter;
/// use thousands::Separable;
/// fn main() {
///     assert_eq!(kb(1000, 3, "k"),  kbfmt(1000, 3, "k"));
///     assert_eq!(kb(1000, 3, "kB"), "1.000kB");
///     assert_eq!(kb(1000, 2, "k"),  "1.00k");
///     assert_eq!(kb(1000, 1, "k"),  "1.0k");
///     assert_eq!(kb(1000, 0, "k"),  kbfmt(1000, 0, "k"));
///     assert_eq!(kb(1000, 0, "k"),  "1k");
/// }
/// build_units_converter!(kb, 1000);
/// pub fn kbfmt<T: TryInto<i64>>(byte_count: T, precision: usize, unit_lbl: &str) -> String {
///     let size: i64 = byte_count.try_into().unwrap_or(0);
///     let units = size as f64 / 1000 as f64;
///     let unit_fmt = format!("{units:.precision$}{unit_lbl}");
///     unit_fmt.separate_with_commas()
/// }
/// ```
#[macro_export]
macro_rules! build_units_converter {
    ($name: ident, $units_base: expr) => {
        /// Formats a integral value into a mulitiple-byte units format based on stringify($units_base)
        /// bytes per unit.
        ///
        /// This function is generated at compile time by [build_units_converter] macro. If
        /// the `byte_count` parameter cannot be converted to an `i64`, an error will be logged
        /// and 0 will be used. If the `precision` parameter is 0 the multiple-byte unit will be
        /// formatted as an integral value.
        ///
        /// # Arguments
        ///
        /// * `byte_count` the byte count that will be converted to the multiple-byte unit.
        /// * `precision` the number of fractional digits to display.
        /// * `unit_lbl` the label to describe the multiple-byte unit.
        ///
        pub fn $name<T: TryInto<i64>>(byte_count: T, precision: usize, unit_lbl: &str) -> String {
            let size: i64 = byte_count.try_into().unwrap_or_else(|_| {
                log::error!("Yikes... Could not convert multibyte-units byte count to i64, using 0!");
                0
            });
            if size == 0 {
                0.to_string()
            } else {
                let units = size as f64 / $units_base as f64;
                format!("{units:.precision$}{unit_lbl}")
                    .as_str()
                    .separate_by_policy(thousands::policies::COMMA_SEPARATOR)
            }
        }
    };
}

// Formats a `i64` value into petabyte units where 1 kilobyte is 1024 bytes.
build_units_converter!(pib_fmt, PIB);
// Formats a `i64` value into terabyte units where 1 kilobyte is 1024 bytes.
build_units_converter!(tib_fmt, TIB);
// Formats a `i64` value into gigabyte units where 1 kilobyte is 1024 bytes.
build_units_converter!(gib_fmt, GIB);
// Formats a `i64` value into megabyte units where 1 kilobyte is 1024 bytes.
build_units_converter!(mib_fmt, MIB);
// Formats a `i64` value into kilobyte units where 1 kilobyte is 1024 bytes.
build_units_converter!(kib_fmt, KIB);

/// Formats a `i64` value into a multiple-byte unit where 1 kilobyte is 1024 bytes.
///
/// The formatter supports petabyte, terabyte, gigabyte, megabyte, and kilobyte
/// unit formats. If the value is exabyte size or larger it will be formatted as a
/// comma separated petabyte value. By default values less than 1 megabyte are
/// formatted as a comma separated byte count. The `fmt_kib` parameter allows
/// thesee values to be formatted as kilobyte units.
///
/// The default labels for the multiple-byte units follow IEC recomendataions.
/// As an example gigabyte units will be labeled *GiB*, megabyte units will be
/// labeled *MiB*, etc.
///
/// # Arguments
///
/// * size: any value that can be converted to a `i64` primitive.
/// * precision: the number of fractional digits for a unit.
/// * fmt_kib: if true values less than 1 megabayte will be formatted as kilobyte units.
pub fn power_of_two_mbu_fmt<T: TryInto<i64>>(size: T, precision: usize, fmt_kib: bool) -> String {
    let byte_count: i64 = size.try_into().unwrap_or_default();
    if byte_count >= PIB {
        pib_fmt(byte_count, precision, PIB_LABEL)
    } else if byte_count >= TIB {
        tib_fmt(byte_count, precision, TIB_LABEL)
    } else if byte_count >= GIB {
        gib_fmt(byte_count, precision, GIB_LABEL)
    } else if byte_count >= MIB {
        mib_fmt(byte_count, precision, MIB_LABEL)
    } else if fmt_kib {
        kib_fmt(byte_count, precision, KIB_LABEL)
    } else {
        byte_count.separate_with_commas()
    }
}

/// A variadic version of the multiple-byte formatter in the `fmt` module.
///
/// The macro calls [power_of_two_mbu_fmt] to format multiple-byte units. It
/// has the same parameters as the function and is a direct replacement.
///
/// Variadic versions of the macro are available for common use cases. The
/// precision parameter defaults to [DEFAULT_MULTIBYTE_PRECISION] and the
/// `fmt_kib` parameter defaults to `false`. The macro has a special case
/// that allows `KiB` to be formatted without having to specify the default
/// precision.
///
/// # Examples
///
/// ```
/// # use toolslib::mbufmt;
/// assert_eq!(mbufmt!(i64::pow(1024, 6), 0), "1,024 PiB");
/// assert_eq!(mbufmt!(i64::pow(1024, 5), 0), "1 PiB");
/// assert_eq!(mbufmt!(i64::pow(1024, 4), 1), "1.0 TiB");
/// assert_eq!(mbufmt!(i64::pow(1024, 3), 2), "1.00 GiB");
/// assert_eq!(mbufmt!(i64::pow(1024, 2), 3), "1.000 MiB");
/// assert_eq!(mbufmt!(i64::pow(1024, 2)),    "1.000 MiB");
/// assert_eq!(mbufmt!(1024, 50),             "1,024");
/// assert_eq!(mbufmt!(1024),                 "1,024");
/// assert_eq!(mbufmt!(1024, true),           "1.000 KiB");
/// assert_eq!(mbufmt!(896, true),            "0.875 KiB");
/// assert_eq!(mbufmt!(1024, 3, true),        "1.000 KiB");
/// ```
#[macro_export]
macro_rules! mbufmt {
    ($byte_count:expr, true) => {
        $crate::fmt::power_of_two_mbu_fmt($byte_count, $crate::fmt::DEFAULT_MULTIBYTE_PRECISION, true)
    };
    ($byte_count:expr, $precision:expr, $fmt_kib:expr) => {
        $crate::fmt::power_of_two_mbu_fmt($byte_count, $precision, $fmt_kib)
    };
    ($byte_count:expr, $precision:expr) => {
        $crate::fmt::power_of_two_mbu_fmt($byte_count, $precision, false)
    };
    ($byte_count:expr) => {
        $crate::fmt::power_of_two_mbu_fmt($byte_count, $crate::fmt::DEFAULT_MULTIBYTE_PRECISION, false)
    };
}

/// A variadic version of the petabyte formatter in the `fmt` module.
///
/// The macro calls [pib_fmt] to format multiple-byte units. It has the
/// same parameters as the function and is a equivalent replacement.
///
/// Variadic versions of the macro are available for common use cases. The
/// precision parameter defaults to [DEFAULT_MULTIBYTE_PRECISION] and the
/// label parameter defaults to [PIB_LABEL].
///
/// # Examples
///
/// ```
/// # use toolslib::pib;
/// let units: usize = usize::pow(1024, 5);
/// assert_eq!(pib!(units, 1),                "1.0 PiB");
/// assert_eq!(pib!(units, 2),                "1.00 PiB");
/// assert_eq!(pib!(units, 3),                "1.000 PiB");
/// assert_eq!(pib!(units),                   "1.000 PiB");
/// assert_eq!(pib!(i64::pow(1024, 4) * 512), "0.500 PiB");
/// assert_eq!(pib!(units * 1024, 0, " Pb"),  "1,024 Pb");
/// ```
#[macro_export]
macro_rules! pib {
    ($byte_count:expr, $precision:expr, $label:expr) => {
        $crate::fmt::pib_fmt($byte_count, $precision, $label)
    };
    ($byte_count:expr, $precision:expr) => {
        $crate::fmt::pib_fmt($byte_count, $precision, $crate::fmt::PIB_LABEL)
    };
    ($byte_count:expr) => {
        $crate::fmt::pib_fmt($byte_count, $crate::fmt::DEFAULT_MULTIBYTE_PRECISION, $crate::fmt::PIB_LABEL)
    };
}

/// A variadic version of the terabyte formatter in the `fmt` module.
///
/// The macro calls [tib_fmt] to format multiple-byte units. It has the
/// same parameters as the function and is a equivalent replacement.
///
/// Variadic versions of the macro are available for common use cases. The
/// precision parameter defaults to [DEFAULT_MULTIBYTE_PRECISION] and the
/// label parameter defaults to [TIB_LABEL].
///
/// # Examples
///
/// ```
/// # use toolslib::tib;
/// let units = u64::pow(1024, 4);
/// assert_eq!(tib!(units, 1),                "1.0 TiB");
/// assert_eq!(tib!(units, 2),                "1.00 TiB");
/// assert_eq!(tib!(units, 3),                "1.000 TiB");
/// assert_eq!(tib!(units),                   "1.000 TiB");
/// assert_eq!(tib!(i64::pow(1024, 3) * 512), "0.500 TiB");
/// assert_eq!(tib!(units * 1024, 0, " tB"),  "1,024 tB");
/// ```
#[macro_export]
macro_rules! tib {
    ($byte_count:expr, $precision:expr, $label:expr) => {
        $crate::fmt::tib_fmt($byte_count, $precision, $label)
    };
    ($byte_count:expr, $precision:expr) => {
        $crate::fmt::tib_fmt($byte_count, $precision, $crate::fmt::TIB_LABEL)
    };
    ($byte_count:expr) => {
        $crate::fmt::tib_fmt($byte_count, $crate::fmt::DEFAULT_MULTIBYTE_PRECISION, $crate::fmt::TIB_LABEL)
    };
}

/// A variadic version of the gigabyte formatter in the `fmt` module.
///
/// The macro calls [gib_fmt] to format multiple-byte units. It has the
/// same parameters as the function and is a equivalent replacement.
///
/// Variadic versions of the macro are available for common use cases. The
/// precision parameter defaults to [DEFAULT_MULTIBYTE_PRECISION] and the
/// label parameter defaults to [GIB_LABEL].
///
/// # Examples
///
/// ```
/// # use toolslib::gib;
/// let units = u64::pow(1024, 3);
/// assert_eq!(gib!(units, 1),                "1.0 GiB");
/// assert_eq!(gib!(units, 2),                "1.00 GiB");
/// assert_eq!(gib!(units, 3),                "1.000 GiB");
/// assert_eq!(gib!(units),                   "1.000 GiB");
/// assert_eq!(gib!(u64::pow(1024, 2) * 256), "0.250 GiB");
/// assert_eq!(gib!(units * 1024, 0, " GB"),  "1,024 GB");
/// ```
#[macro_export]
macro_rules! gib {
    ($byte_count:expr, $precision:expr, $label:expr) => {
        $crate::fmt::gib_fmt($byte_count, $precision, $label)
    };
    ($byte_count:expr, $precision:expr) => {
        $crate::fmt::gib_fmt($byte_count, $precision, $crate::fmt::GIB_LABEL)
    };
    ($byte_count:expr) => {
        $crate::fmt::gib_fmt($byte_count, $crate::fmt::DEFAULT_MULTIBYTE_PRECISION, $crate::fmt::GIB_LABEL)
    };
}

/// A variadic version of the megabyte formatter in the `fmt` module.
///
/// The macro calls [mib_fmt] to format multiple-byte units. It has the
/// same parameters as the function and is a equivalent replacement.
///
/// Variadic versions of the macro are available for common use cases. The
/// precision parameter defaults to [DEFAULT_MULTIBYTE_PRECISION] and the
/// label parameter defaults to [MIB_LABEL].
///
/// # Examples
///
/// ```
/// # use toolslib::mib;
/// let units = i32::pow(1024, 2);
/// assert_eq!(mib!(units, 1),               "1.0 MiB");
/// assert_eq!(mib!(units, 2),               "1.00 MiB");
/// assert_eq!(mib!(units, 3),               "1.000 MiB");
/// assert_eq!(mib!(units),                  "1.000 MiB");
/// assert_eq!(mib!(1024 * 128),             "0.125 MiB");
/// assert_eq!(mib!(units * 1024, 0, " MB"), "1,024 MB");
/// ```
#[macro_export]
macro_rules! mib {
    ($byte_count:expr, $precision:expr, $label:expr) => {
        $crate::fmt::mib_fmt($byte_count, $precision, $label)
    };
    ($byte_count:expr, $precision:expr) => {
        $crate::fmt::mib_fmt($byte_count, $precision, $crate::fmt::MIB_LABEL)
    };
    ($byte_count:expr) => {
        $crate::fmt::mib_fmt($byte_count, $crate::fmt::DEFAULT_MULTIBYTE_PRECISION, $crate::fmt::MIB_LABEL)
    };
}

/// A variadic version of the kilobyte formatter in the `fmt` module.
///
/// The macro calls [kib_fmt] to format multiple-byte units. It has the
/// same parameters as the function and is a equivalent replacement.
///
/// Variadic versions of the macro are available for common use cases. The
/// precision parameter defaults to [DEFAULT_MULTIBYTE_PRECISION] and the
/// label parameter defaults to [KIB_LABEL].
///
/// # Examples
///
/// ```
/// # use toolslib::kib;
/// let units = 1024 as u16;
/// assert_eq!(kib!(units, 1),            "1.0 KiB");
/// assert_eq!(kib!(units, 2),            "1.00 KiB");
/// assert_eq!(kib!(units, 3),            "1.000 KiB");
/// assert_eq!(kib!(units),               "1.000 KiB");
/// assert_eq!(kib!(768),                 "0.750 KiB");
/// assert_eq!(kib!(1024 * 1024, 0, "k"), "1,024k");
/// ```
#[macro_export]
macro_rules! kib {
    ($byte_count:expr, $precision:expr, $label:expr) => {
        $crate::fmt::kib_fmt($byte_count, $precision, $label)
    };
    ($byte_count:expr, $precision:expr) => {
        $crate::fmt::kib_fmt($byte_count, $precision, $crate::fmt::KIB_LABEL)
    };
    ($byte_count:expr) => {
        $crate::fmt::kib_fmt($byte_count, $crate::fmt::DEFAULT_MULTIBYTE_PRECISION, $crate::fmt::KIB_LABEL)
    };
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn kib() {
        assert_eq!(kib_fmt(KIB, 0, ""), "1");
        assert_eq!(kib_fmt(KIB, 1, "k"), "1.0k");
        assert_eq!(kib_fmt(KIB * 1024, DEFAULT_MULTIBYTE_PRECISION, KIB_LABEL), "1,024.000 KiB");
    }

    #[test]
    fn mib() {
        assert_eq!(mib_fmt(MIB, 0, ""), "1");
        assert_eq!(mib_fmt(MIB, 1, "M"), "1.0M");
        assert_eq!(mib_fmt(MIB * 1024, DEFAULT_MULTIBYTE_PRECISION, MIB_LABEL), "1,024.000 MiB");
    }

    #[test]
    fn gib() {
        assert_eq!(gib_fmt(GIB, 0, ""), "1");
        assert_eq!(gib_fmt(GIB, 1, "G"), "1.0G");
        assert_eq!(gib_fmt(GIB * 1024, DEFAULT_MULTIBYTE_PRECISION, GIB_LABEL), "1,024.000 GiB");
    }

    #[test]
    fn tib() {
        assert_eq!(tib_fmt(TIB, 0, ""), "1");
        assert_eq!(tib_fmt(TIB, 1, "T"), "1.0T");
        assert_eq!(tib_fmt(TIB * 1024, DEFAULT_MULTIBYTE_PRECISION, TIB_LABEL), "1,024.000 TiB");
    }

    #[test]
    fn pib() {
        assert_eq!(pib_fmt(PIB, 0, ""), "1");
        assert_eq!(pib_fmt(PIB, 1, "P"), "1.0P");
        assert_eq!(pib_fmt(PIB * 1024, DEFAULT_MULTIBYTE_PRECISION, PIB_LABEL), "1,024.000 PiB");
    }

    #[test]
    fn power_of_two_mbu() {
        assert_eq!(power_of_two_mbu_fmt(PIB, 0, false), "1 PiB");
        assert_eq!(power_of_two_mbu_fmt(TIB, 1, false), "1.0 TiB");
        assert_eq!(power_of_two_mbu_fmt(GIB, 2, false), "1.00 GiB");
        assert_eq!(power_of_two_mbu_fmt(MIB, 3, false), "1.000 MiB");
        assert_eq!(power_of_two_mbu_fmt(KIB, 5, false), "1,024");
        assert_eq!(power_of_two_mbu_fmt(KIB, 5, true), "1.00000 KiB");
    }

    #[test]
    fn comma() {
        assert_eq!(commafy(1024), "1,024");
        assert_eq!(commafy(-12345.678), "-12,345.678");
        assert_eq!(commafy("KiB is 1024 bytes."), "KiB is 1,024 bytes.");
        assert_eq!(commafy("abcdefg"), "abcdefg");
        // this will cause separatable to panic.
        // assert_eq!(commafy("abcdefg."), "abcdefg.");
    }

    #[test]
    fn float() {
        let testcase = 123.446;
        assert_eq!(fmt_float(&Some(testcase), 3), "123.446");
        assert_eq!(fmt_float(&Some(testcase), 2), "123.45");
        assert_eq!(fmt_float(&Some(testcase), 1), "123.4");
        assert_eq!(fmt_float(&Some(testcase), 0), "123");
    }
}
